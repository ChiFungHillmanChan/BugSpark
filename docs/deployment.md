# BugSpark Deployment Guide

This guide covers deploying BugSpark to production using Render (API) and Vercel (Dashboard).

## Required Services

| Service | Purpose | Providers |
|---------|---------|-----------|
| **PostgreSQL** | Primary database | Supabase, Neon, Render Postgres, AWS RDS |
| **S3-compatible storage** | Screenshot uploads | AWS S3, Cloudflare R2, DigitalOcean Spaces, MinIO |
| **Node.js hosting** | Dashboard (Next.js) | Vercel, Netlify, Cloudflare Pages |
| **Python hosting** | API (FastAPI) | Render, Railway, Fly.io, AWS ECS |

### Optional Services

| Service | Purpose | Providers |
|---------|---------|-----------|
| **Anthropic API** | AI bug analysis | Anthropic (requires API key) |
| **Resend** | Transactional emails | Resend |
| **Sentry** | Error tracking | Sentry |

---

## Environment Variable Reference

### API (`packages/api`)

See `packages/api/.env.example` for the full list with comments.

| Variable | Required | Default | Description |
|----------|----------|---------|-------------|
| `ENVIRONMENT` | Yes | `development` | Set to `production` for production deployments |
| `DATABASE_URL` | Yes | (local) | PostgreSQL async connection string (`postgresql+asyncpg://...`) |
| `JWT_SECRET` | Yes | - | Random secret, min 32 characters in production. Generate: `python -c "import secrets; print(secrets.token_urlsafe(64))"` |
| `JWT_ALGORITHM` | No | `HS256` | JWT signing algorithm |
| `JWT_ACCESS_TOKEN_EXPIRE_MINUTES` | No | `60` | Access token TTL |
| `JWT_REFRESH_TOKEN_EXPIRE_DAYS` | No | `30` | Refresh token TTL |
| `ENCRYPTION_KEY` | Yes (prod) | - | Fernet key for encrypting integration secrets. Generate: `python -c "from cryptography.fernet import Fernet; print(Fernet.generate_key().decode())"` |
| `S3_ENDPOINT_URL` | Yes | (local) | S3-compatible endpoint (must not be localhost in production) |
| `S3_ACCESS_KEY` | Yes | - | S3 access key ID |
| `S3_SECRET_KEY` | Yes | - | S3 secret access key |
| `S3_BUCKET_NAME` | Yes | `bugspark-uploads` | S3 bucket name |
| `S3_PUBLIC_URL` | Yes | - | Public URL prefix for uploaded files |
| `CORS_ORIGINS` | Yes | - | Comma-separated allowed origins (include your dashboard URL) |
| `CORS_ORIGIN_REGEX` | No | - | Regex for dynamic origins (e.g., Vercel preview URLs) |
| `FRONTEND_URL` | Yes | - | Dashboard URL for redirects and email links |
| `COOKIE_SECURE` | Yes (prod) | `false` | Set to `true` when serving over HTTPS |
| `COOKIE_SAMESITE` | Yes (prod) | `lax` | Set to `none` for cross-origin API/dashboard deployments |
| `SUPERADMIN_EMAIL` | No | - | Auto-create superadmin user on startup |
| `SUPERADMIN_PASSWORD` | No | - | Superadmin password (pair with email above) |
| `ANTHROPIC_API_KEY` | No | - | Enables AI bug analysis |
| `AI_MODEL` | No | `claude-haiku-4-5-20251001` | Anthropic model ID for analysis |
| `RESEND_API_KEY` | No | - | Enables transactional emails |
| `EMAIL_FROM_ADDRESS` | No | `BugSpark <noreply@bugspark.dev>` | Sender address for emails |
| `SENTRY_DSN` | No | - | Enables Sentry error tracking |

### Dashboard (`packages/dashboard`)

See `packages/dashboard/.env.example` for the full list with comments.

| Variable | Required | Default | Description |
|----------|----------|---------|-------------|
| `NEXT_PUBLIC_API_URL` | Yes | `http://localhost:8000/api/v1` | BugSpark API base URL |
| `NEXT_PUBLIC_S3_HOSTNAME` | No | - | S3 hostname for `next/image` remote patterns |
| `NEXT_PUBLIC_SENTRY_DSN` | No | - | Sentry DSN for client and server error tracking |
| `NEXT_PUBLIC_BUGSPARK_API_KEY` | No | - | Embed BugSpark widget on the dashboard (dogfooding) |

---

## Render Deployment (API)

The API is configured via `render.yaml` (Infrastructure as Code).

### Setup

1. **Connect your GitHub repo** to Render.

2. **Create a PostgreSQL database** on Render (or use an external provider like Supabase/Neon).

3. **Create a new Web Service** from `render.yaml`, or create one manually with:
   - **Root directory:** `packages/api`
   - **Build command:** `pip install . && alembic upgrade head`
   - **Start command:** `uvicorn app.main:app --host 0.0.0.0 --port $PORT --workers 2 --loop uvloop --http httptools`
   - **Health check path:** `/health`

4. **Set environment variables** in Render's dashboard:
   - `ENVIRONMENT=production`
   - `DATABASE_URL` -- your PostgreSQL connection string (async driver: `postgresql+asyncpg://...`)
   - `JWT_SECRET` -- auto-generated by Render if using `render.yaml`
   - `ENCRYPTION_KEY` -- generate a Fernet key (see above)
   - `S3_*` variables -- your S3-compatible storage credentials
   - `CORS_ORIGINS` -- your Vercel dashboard URL
   - `CORS_ORIGIN_REGEX` -- optional regex for dynamic origins (not needed for single domain setup)
   - `FRONTEND_URL` -- your dashboard URL
   - `COOKIE_SECURE=true`
   - `COOKIE_SAMESITE=none` (required for cross-origin cookie sharing)

5. **Verify deployment:**
   ```bash
   curl https://api.bugspark.hillmanchan.com/health
   # Expected: {"status":"healthy","db":"connected"}
   ```

### Render Auto-Deploy

Render auto-deploys when changes are pushed to `main`. The `render.yaml` runs `alembic upgrade head` as part of the build, so database migrations are applied automatically on each deploy.

---

## Vercel Deployment (Dashboard)

### Setup

1. **Import the repository** in Vercel.

2. **Configure the project:**
   - **Root directory:** `packages/dashboard`
   - **Framework preset:** Next.js (auto-detected)
   - **Build command:** `pnpm build` (default)

3. **Set environment variables** in Vercel's project settings:
   - `NEXT_PUBLIC_API_URL` -- your API URL (e.g., `https://api.bugspark.hillmanchan.com/api/v1`)
   - `NEXT_PUBLIC_S3_HOSTNAME` -- your S3 public hostname (for `next/image`)
   - `NEXT_PUBLIC_SENTRY_DSN` -- optional, Sentry DSN

4. **Verify deployment** by visiting your Vercel URL and confirming the login page loads.

### Vercel Auto-Deploy

Vercel auto-deploys on push to `main` and creates preview deployments for pull requests. If using preview deployments, set `CORS_ORIGIN_REGEX` on the API to allow the dynamic Vercel preview URLs.

---

## CORS, Cookies, and Domain Configuration

BugSpark uses HttpOnly cookies for authentication. Cross-origin deployments (API on Render, Dashboard on Vercel) require specific configuration:

### Same-domain deployment
If API and Dashboard share a domain (e.g., `api.bugspark.hillmanchan.com` and `bugspark.hillmanchan.com`):
- `COOKIE_SECURE=true`
- `COOKIE_SAMESITE=lax`
- `CORS_ORIGINS=https://bugspark.hillmanchan.com`

### Cross-origin deployment (different domains)
If API and Dashboard are on different domains (e.g., `api.bugspark.hillmanchan.com` and `bugspark.hillmanchan.com`):
- `COOKIE_SECURE=true`
- `COOKIE_SAMESITE=none` (required for cross-origin cookies)
- `CORS_ORIGINS=https://bugspark.hillmanchan.com`

### Widget CORS
The widget endpoint (`/api/v1/reports`) uses a dedicated `WidgetCORSMiddleware` that allows requests from any origin authenticated with an API key. No additional CORS configuration is needed for widget users.

---

## Database Migrations

Migrations are managed by Alembic and stored in `packages/api/migrations/versions/`.

### Apply pending migrations
```bash
# Locally
cd packages/api
alembic upgrade head

# On Render: migrations run automatically during build (see render.yaml)
```

### Create a new migration
```bash
cd packages/api
alembic revision --autogenerate -m "add_new_table"
# Review the generated migration in migrations/versions/
# Commit and push to deploy
```

### Rollback a migration
```bash
cd packages/api
alembic downgrade -1  # Roll back one revision
```

---

## Backup Strategy

See `docs/backup-strategy.md` for the full backup plan.

Key points:
- **Database:** Use your provider's automated backups (Supabase, Neon, and Render Postgres all offer point-in-time recovery). For self-managed Postgres, schedule `pg_dump` via cron.
- **S3 storage:** Enable versioning on your S3 bucket. For critical data, enable cross-region replication.
- **Secrets:** Store environment variables in your deployment platform's secret manager. Keep an encrypted offline copy of `ENCRYPTION_KEY` and `JWT_SECRET` -- losing these invalidates all tokens and encrypted integration credentials.

---

## CI/CD Pipeline

The project uses GitHub Actions (`.github/workflows/`):

### Post-Merge Pipeline (`deploy.yml`)
Triggered on push to `main`:
1. **test-api** -- runs `pytest` on the API
2. **test-dashboard** -- runs `vitest` on the dashboard
3. **test-widget** -- runs `vitest` on the widget
4. **build-widget** -- builds the widget and uploads the artifact
5. **smoke-test** -- waits for Render deploy, then checks `GET /health`

Actual deployment is handled by platform integrations (Render auto-deploy + Vercel auto-deploy), not by the GitHub Action directly.

### CI Pipeline (`ci.yml`)
Triggered on pull requests to `main`:
- Lints dashboard and widget
- Runs all test suites
- Builds all packages via Turbo

---

## Docker (Local Development)

The root `docker-compose.yml` provides PostgreSQL and MinIO for local development:

```bash
# Start services
pnpm docker:up

# Stop services
pnpm docker:down
```

This starts:
- **PostgreSQL 16** on port `5432` (user: `bugspark`, password: `bugspark_dev`, db: `bugspark`)
- **MinIO** on port `9000` (API) and `9001` (console), with a pre-created `bugspark-uploads` bucket

The Dockerfile at `packages/api/Dockerfile` is a multi-stage build for production API deployments. It runs as a non-root user (`appuser`) and includes a health check.
