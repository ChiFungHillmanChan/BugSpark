# 1.1 Security Vulnerability Fixes

## Priority: CRITICAL

These 4 security issues must be fixed before any public launch.

---

## Issue 1: Mass Assignment via `setattr` Loop

### Problem
Multiple routers use a `setattr` loop with Pydantic schema filtering as the only defense. An attacker could potentially set unintended fields if the schema is misconfigured.

### Affected Files
- `packages/api/app/routers/auth.py` (line ~177)
- `packages/api/app/routers/reports.py` (line ~262)
- `packages/api/app/routers/webhooks.py` (line ~90)
- `packages/api/app/routers/integrations.py` (line ~126)

### Fix
Add explicit field allowlists for each update operation:

```python
# Before (vulnerable)
for field, value in update_data.model_dump(exclude_unset=True).items():
    setattr(db_object, field, value)

# After (safe)
ALLOWED_REPORT_UPDATE_FIELDS = {"title", "description", "status", "severity", "category", "assignee_id"}

update_dict = update_data.model_dump(exclude_unset=True)
for field, value in update_dict.items():
    if field in ALLOWED_REPORT_UPDATE_FIELDS:
        setattr(db_object, field, value)
```

### Implementation Steps
1. Define `ALLOWED_*_FIELDS` constant at the top of each router file
2. Add allowlist check inside each `setattr` loop
3. Add tests that attempt to set disallowed fields (e.g., `id`, `created_at`, `user_id`) and verify they are rejected
4. Repeat for all 4 affected routers

### Tests to Add
- `test_report_update_rejects_disallowed_fields`
- `test_webhook_update_rejects_disallowed_fields`
- `test_integration_update_rejects_disallowed_fields`
- `test_user_update_rejects_disallowed_fields`

---

## Issue 2: Team Invite Email Mismatch

### Problem
`team_service.py:99-125` — `accept_invite` does not verify the accepting user's email matches the invited email. Any authenticated user with the invite token can join.

### Affected Files
- `packages/api/app/services/team_service.py`

### Fix
```python
async def accept_invite(db: AsyncSession, token: str, current_user: User) -> ProjectMember:
    invite = await get_invite_by_token(db, token)
    if not invite:
        raise NotFoundException("Invite not found or expired")

    # ADD THIS CHECK
    if invite.email.lower() != current_user.email.lower():
        raise ForbiddenException("This invite was sent to a different email address")

    # ... rest of accept logic
```

### Implementation Steps
1. Add email comparison check in `accept_invite`
2. Return clear error message if emails don't match
3. Add test: authenticated user with different email tries to accept invite → 403

### Tests to Add
- `test_accept_invite_wrong_email_rejected`
- `test_accept_invite_correct_email_accepted`
- `test_accept_invite_case_insensitive_email_match`

---

## Issue 3: HTML Injection in Emails

### Problem
`team_service.py:83-89` and `notification_service.py:71-76` interpolate user/project names into HTML email templates without escaping. A user with name `<script>alert('xss')</script>` could inject HTML.

### Affected Files
- `packages/api/app/services/team_service.py`
- `packages/api/app/services/notification_service.py`

### Fix
```python
from markupsafe import escape
# or use the existing sanitize utility:
from app.utils.sanitize import strip_html_tags

# Before
html_body = f"<p>{user.name} invited you to {project.name}</p>"

# After
html_body = f"<p>{escape(user.name)} invited you to {escape(project.name)}</p>"
```

### Implementation Steps
1. Add `markupsafe` to dependencies (or use existing `strip_html_tags` from `app/utils/sanitize.py`)
2. Escape all user-provided values before inserting into HTML templates
3. Audit all email templates for unescaped interpolation
4. Add test: create user with HTML in name, send email, verify HTML is escaped in output

### Tests to Add
- `test_email_escapes_html_in_user_name`
- `test_email_escapes_html_in_project_name`

---

## Issue 4: Widget URL Data Exposure

### Problem
Network interceptor captures full request URLs including query parameters that may contain auth tokens (`?token=xxx`, `?api_key=xxx`).

### Affected Files
- `packages/widget/src/collectors/network-interceptor.ts`

### Fix
```typescript
const SENSITIVE_PARAMS = ['token', 'api_key', 'apiKey', 'key', 'secret',
  'password', 'auth', 'access_token', 'refresh_token', 'jwt', 'session',
  'credential', 'authorization'];

function sanitizeUrl(url: string): string {
  try {
    const parsed = new URL(url);
    for (const param of SENSITIVE_PARAMS) {
      if (parsed.searchParams.has(param)) {
        parsed.searchParams.set(param, '[REDACTED]');
      }
    }
    return parsed.toString();
  } catch {
    return url;
  }
}
```

### Implementation Steps
1. Create `sanitizeUrl` utility in `packages/widget/src/utils/url-sanitizer.ts`
2. Apply to all URLs captured by network interceptor
3. Also apply to URLs in console log entries (stack traces may contain URLs)
4. Add tests with various URL patterns

### Tests to Add
- `test_sanitize_url_redacts_token_param`
- `test_sanitize_url_preserves_safe_params`
- `test_sanitize_url_handles_malformed_urls`
- `test_network_interceptor_uses_sanitized_urls`
